#!/usr/bin/env python3
# Generates page metadata for code paging system
# Creates page map from binary file for demand-loading

from __future__ import annotations
import os
import sys
from datetime import datetime

# Page size in bytes (4KB pages for efficient management)
PAGE_SIZE = 4096

def generate_page_map(elf_path: str, bin_path: str, output_dir: str):
    """Generate page metadata from binary file.
    
    Creates pages covering the entire binary, splitting into header/data pages
    (at RAM addresses) and code pages (at overlay addresses).
    """
    # Create pages from the binary file directly
    # This works because the binary is what actually gets embedded
    bin_size = os.path.getsize(bin_path)
    if bin_size == 0:
        print("Error: Binary file is empty", file=sys.stderr)
        return
    
    print(f"Creating {((bin_size + PAGE_SIZE - 1) // PAGE_SIZE)} pages from {bin_size} byte binary", file=sys.stderr)
    
    # Create pages covering the entire binary
    # IMPORTANT: Code pages should use overlay address (0x20040000)
    # Header/data pages use RAM address (0x20030000)
    sections = []
    CODE_OVERLAY_BASE = 0x20040000
    RAM_BASE = 0x20030000
    
    # Estimate: first ~64KB is header+data, rest is code
    # This is a heuristic that works well for typical application layouts
    header_data_size = min(64 * 1024, bin_size)
    code_offset = header_data_size
    
    for i in range((bin_size + PAGE_SIZE - 1) // PAGE_SIZE):
        page_offset = i * PAGE_SIZE
        page_size = min(PAGE_SIZE, bin_size - page_offset)
        
        # Determine if this is code or data based on offset
        if page_offset < header_data_size:
            # Header/data pages at RAM addresses
            page_addr = RAM_BASE + page_offset
            sections.append((".binary_page_data", page_addr, page_offset, page_size))
        else:
            # Code pages at overlay addresses
            code_page_offset = page_offset - code_offset
            page_addr = CODE_OVERLAY_BASE + code_page_offset
            sections.append((".binary_page_code", page_addr, page_offset, page_size))
    
    # Sort sections by address
    sections.sort(key=lambda x: x[1])
    
    # Get binary size
    bin_size = os.path.getsize(bin_path)
    
    # Create page map
    pages = []
    page_id = 0
    
    # Process each section
    for name, addr, offset, size in sections:
        if size == 0:
            continue
        
        # Calculate number of pages needed for this section
        num_pages = (size + PAGE_SIZE - 1) // PAGE_SIZE
        
        for i in range(num_pages):
            page_offset = offset + (i * PAGE_SIZE)
            page_size = min(PAGE_SIZE, size - (i * PAGE_SIZE))
            page_addr = addr + (i * PAGE_SIZE)
            
            # Ensure page is within binary
            if page_offset + page_size > bin_size:
                page_size = bin_size - page_offset
                if page_size <= 0:
                    break
            
            pages.append({
                'id': page_id,
                'name': name,
                'addr': page_addr,
                'offset': page_offset,
                'size': page_size,
                'section': name
            })
            page_id += 1
    
    # Generate C header with page metadata
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S") + " Local"
    
    header = f"""/* ===========================================================================
 *  AUTO-GENERATED FILE - DO NOT EDIT unless you know what you're doing!!
 *  ---------------------------------------------------------------------------
 *  Generated by : page_gen.py
 *  Timestamp    : {timestamp}
 *  File         : app_page_map.h
 *  This file contains page metadata for code paging system.
 * ===========================================================================
 */
#pragma once
#include <stdint.h>
#include <stddef.h>

#define APP_PAGE_SIZE {PAGE_SIZE}
#define APP_PAGE_COUNT {len(pages)}
#define APP_BINARY_SIZE {bin_size}

// Page metadata structure
typedef struct {{
  uint32_t page_id;
  uint32_t flash_offset;  // Offset in raw_data[] array
  uint32_t size;          // Page size in bytes
  uint32_t sram_addr;     // Target SRAM address (0x20030000 + offset)
  uint16_t section_id;    // Section identifier
}} AppPageInfo;

// Page map - maps page IDs to flash offsets and sizes
extern const AppPageInfo app_page_map[APP_PAGE_COUNT];

// Get page info by ID
static inline const AppPageInfo* app_get_page_info(uint32_t page_id) {{
  if (page_id >= APP_PAGE_COUNT) return NULL;
  return &app_page_map[page_id];
}}

// Find page containing an address
static inline const AppPageInfo* app_find_page(uint32_t addr) {{
  for (uint32_t i = 0; i < APP_PAGE_COUNT; i++) {{
    const AppPageInfo* page = &app_page_map[i];
    if (addr >= page->sram_addr && addr < page->sram_addr + page->size) {{
      return page;
    }}
  }}
  return NULL;
}}
"""
    
    # Generate implementation file
    impl = f"""/* ===========================================================================
 *  AUTO-GENERATED FILE - DO NOT EDIT unless you know what you're doing!!
 *  ---------------------------------------------------------------------------
 *  Generated by : page_gen.py
 *  Timestamp    : {timestamp}
 *  File         : app_page_map.c
 * ===========================================================================
 */
#include "app_page_map.h"
#include <string.h>

// Section identifiers
#define SEC_APP_HDR  0
#define SEC_TEXT     1
#define SEC_RODATA   2

static uint16_t get_section_id(const char* name) {{
  if (name && strncmp(name, ".app_hdr", 8u) == 0) return SEC_APP_HDR;
  if (name && strncmp(name, ".text", 5u) == 0) return SEC_TEXT;
  return SEC_RODATA;
}}

const AppPageInfo app_page_map[APP_PAGE_COUNT] = {{
"""
    
    # Base SRAM address
    SRAM_BASE = 0x20030000
    
    for page in pages:
        section_id = 0
        if '.app_hdr' in page['name']:
            section_id = 0
        elif '.text' in page['name']:
            section_id = 1
        else:
            section_id = 2
        
        impl += f"""  {{ {page['id']}, {page['offset']}, {page['size']}, {page['addr']}, {section_id} }},  // {page['name']}\n"""
    
    impl += "};\n"
    
    # Write files
    os.makedirs(output_dir, exist_ok=True)
    
    header_path = os.path.join(output_dir, "app_page_map.h")
    impl_path = os.path.join(output_dir, "app_page_map.c")
    
    with open(header_path, 'w') as f:
        f.write(header)
    
    with open(impl_path, 'w') as f:
        f.write(impl)
    
    print(f"Generated page map: {len(pages)} pages")
    print(f"  Header: {header_path}")
    print(f"  Impl: {impl_path}")

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: page_gen.py <elf_path> <bin_path> <output_dir>", file=sys.stderr)
        sys.exit(1)
    
    elf_path = sys.argv[1]
    bin_path = sys.argv[2]
    output_dir = sys.argv[3]
    
    generate_page_map(elf_path, bin_path, output_dir)

