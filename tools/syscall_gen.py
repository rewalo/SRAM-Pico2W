#!/usr/bin/env python3
# Generates C++ syscall wrappers from syscalls.def
# Creates headers and dispatch tables for app and kernel

from __future__ import annotations
import re, os, sys, hashlib
from datetime import datetime
from typing import Optional

# Maximum number of syscall arguments supported
MAX_SYSCALL_ARGS = 30

# Helper function to generate argument list strings (a0, a1, ..., aN)
def gen_arg_list(count: int) -> str:
    """Generate comma-separated argument list: a0, a1, ..., aN"""
    return ", ".join(f"a{i}" for i in range(count))

# Helper function to generate parameter variable list (_p0, _p1, ..., _pN)
def gen_param_var_list(count: int) -> str:
    """Generate comma-separated parameter variable list: _p0, _p1, ..., _pN"""
    return ", ".join(f"_p{i}" for i in range(count))

# Helper function to generate parameter list for function signatures
def gen_param_list(count: int, param_type: str = "uintptr_t") -> str:
    """Generate comma-separated parameter list: uintptr_t a0, uintptr_t a1, ..., uintptr_t aN"""
    return ", ".join(f"{param_type} a{i}" for i in range(count))

# Helper function to generate parameter list starting from a specific index
def gen_param_list_from(start: int, count: int, param_type: str = "uintptr_t") -> str:
    """Generate comma-separated parameter list starting from index: uintptr_t a{start}, uintptr_t a{start+1}, ..., uintptr_t a{start+count-1}"""
    return ", ".join(f"{param_type} a{i}" for i in range(start, start + count))

# Generate header banner for auto-generated files
def gen_header(
    filename: str,
    *,
    generator: str = "syscall_gen.py",
    timestamp: Optional[datetime] = None,
    file_hash: Optional[str] = None,
) -> str:
    ts = (timestamp or datetime.now()).strftime("%Y-%m-%d %H:%M:%S") + " Local"
    hash_line = f" *  Source Hash:  {file_hash or 'N/A'}".ljust(78) + "\n"

    banner = f"""\
/* ===========================================================================
 *  AUTO-GENERATED FILE - DO NOT EDIT unless you know what you're doing!!
 *  ---------------------------------------------------------------------------
 *  Generated by : {generator:<30}
 *  Timestamp    : {ts}
 *  File         : {filename}
{hash_line} *  This file is produced automatically during the build process.
 *  Manual edits will be overwritten on the next regeneration.
 * ===========================================================================
 */
"""
    return banner

# Setup paths
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
DEF_FILE = os.path.join(ROOT, "config", "syscalls.def")
APP_GEN  = os.path.join(ROOT, "app", "src", "generated")
KER_GEN  = os.path.join(ROOT, "kernel", "src", "generated")

os.makedirs(APP_GEN, exist_ok=True)
os.makedirs(KER_GEN, exist_ok=True)

# Parse syscalls.def and extract definitions
print("Parsing syscalls.def ...")
with open(DEF_FILE, "r") as f:
    original_def = f.read()

file_hash = hashlib.sha256(original_def.encode("utf-8")).hexdigest()[:16]
timestamp = datetime.now()

# Strip comments from definition file
lines = original_def.splitlines()
clean = []
block = False

for line in lines:
    if "/*" in line: block = True
    if block:
        if "*/" in line: block = False
        continue
    line = re.sub(r"//.*", "", line)
    if line.strip(): clean.append(line)

# Parse SYSCALL entries - matches: SYSCALL(name, ret, (args)) [; @member obj cls method]
pattern = re.compile(
    r"^\s*SYSCALL\(\s*([A-Za-z_]\w*)\s*,\s*([A-Za-z_][\w\s\*]*)\s*,\s*\(([^)]*)\)\s*\)(?:\s*;\s*@(\w+)\s+(\w+)\s+(\w+))?"
)

syscalls = []
for line in clean:
    m = pattern.match(line)
    if m:
        name, ret, args, annot_type, annot_obj, annot_method = m.groups()
        args = [a.strip() for a in args.split(",")] if args.strip() else []
        syscalls.append((name, ret.strip(), args, annot_type, annot_obj, annot_method))

if not syscalls:
    print("No syscalls found")
    sys.exit(1)

print(f"Found {len(syscalls)} syscalls")

def write_file(path: str, content: str):
    with open(path, "w") as f:
        f.write(gen_header(os.path.basename(path), timestamp=timestamp, file_hash=file_hash))
        f.write(content)

# Generate syscall ID enum (used by both app and kernel)
ids = "#pragma once\nenum : unsigned {\n"
for i, (n, _, _, _, _, _) in enumerate(syscalls):
    ids += f"  SYSC_{n} = {i},\n"
ids += f"  SYSC__COUNT = {len(syscalls)}\n}};\n"

write_file(os.path.join(APP_GEN, "syscall_ids.h"), ids)
write_file(os.path.join(KER_GEN, "syscall_ids.h"), ids)
print("syscall_ids.h generated")

# Auto-detect objects from syscall names (ObjectName_methodName pattern)
# Also collect prefix_map for manual overrides (safe_wrappers, custom casts)
detected_objects = set()  # Track objects we auto-detect
object_type_aliases = {}  # Map object name to type alias name

# Map syscall prefixes to manual overrides (for safe_wrappers, custom method casts, method name mappings)
# 
# You ONLY need to add entries here for special cases:
# 1. safe_wrappers: Methods that need pointer validation (e.g., string parameters from app)
# 2. method_casts: Methods that need base class casts or special handling
# 3. method_names: When syscall method name differs from actual method name
#
# For normal methods, auto-detection handles everything automatically!
# Just add: SYSCALL(ObjectName_methodName, ...) and it will work.
#
prefix_map = {
    "Serial_": {
        "obj": "Serial",  # Object name for method_casts
        "safe_wrappers": {
            "print_s": "syscall_safe_wrappers::serialPrintSafe",
            "println_s": "syscall_safe_wrappers::serialPrintlnSafe",
        },
        "method_casts": {
            # Map syscall method name to full cast expression
            # write_b needs to use the base class Print::write method
            "write_b": "static_cast<size_t (arduino::Print::*)(uint8_t)>(&arduino::Print::write)",
            # println() with no args is also on base class Print
            "println": "static_cast<size_t (arduino::Print::*)()>(&arduino::Print::println)",
        }
    },
    "SPI_": {
        "obj": "SPI",
        "safe_wrappers": {
            # beginTransaction needs default SPISettings wrapper
            "beginTransaction": "syscall_safe_wrappers::spiBeginTransaction",
        }
    },
    "Wire_": {
        "obj": "Wire",
        "method_names": {
            # Map syscall method names to actual method names
            "write_b": "write",  # Wire::write(uint8_t)
            "write_buf": "write",  # Wire::write(const uint8_t*, size_t)
        },
        "method_casts": {
            # requestFrom returns size_t and takes (uint8_t, size_t)
            "requestFrom": "static_cast<size_t (TwoWire::*)(uint8_t, size_t)>(&TwoWire::requestFrom)",
        }
    }
}

# First pass: detect objects from syscall names
# We auto-detect all objects; overrides are handled in dispatch phase
for n, ret, args, annot_type, annot_obj, annot_method in syscalls:
    if annot_type == "member":
        continue  # Skip manual annotations
    
    # Check if this syscall matches ObjectName_methodName pattern
    if "_" in n:
        parts = n.split("_", 1)  # Split on first underscore only
        if len(parts) == 2:
            obj_name = parts[0]
            method_name = parts[1]
            detected_objects.add(obj_name)

# Generate type aliases for detected objects
dispatch = ""
for obj_name in sorted(detected_objects):
    # Generate type alias: H{ObjectName} = std::remove_reference_t<decltype({ObjectName})>;
    type_alias = f"H{obj_name}"
    object_type_aliases[obj_name] = type_alias
    dispatch += f"using {type_alias} = std::remove_reference_t<decltype({obj_name})>;\n"

if detected_objects:
    dispatch += "\n"

# Generate dispatch cases for each syscall
for n, ret, args, annot_type, annot_obj, annot_method in syscalls:
    # Always use all MAX_SYSCALL_ARGS - template will extract only what's needed
    arg_list_str = gen_arg_list(MAX_SYSCALL_ARGS)
    
    if annot_type == "member":
        # Manual member annotation takes precedence
        arg_types = ", ".join(a.split()[0] for a in args)
        dispatch += (
            f"  case SYSC_{n}: return detail::invoke_method<&{annot_obj}, "
            f"static_cast<{ret} ({annot_obj}::*)({arg_types})>(&{annot_obj}::{annot_method})"
            f">({arg_list_str});\n"
        )
        continue

    # Check prefix_map first for manual overrides (safe_wrappers, custom methods, method name mappings)
    # Only use overrides if they actually exist for this specific method
    handled = False
    parts_for_prefix = n.split("_", 1) if "_" in n else [n, ""]
    for prefix, cfg in prefix_map.items():
        if n.startswith(prefix):
            key = n[len(prefix):]
            parts = parts_for_prefix  # Reuse for method_name mapping
            if "safe_wrappers" in cfg and key in cfg["safe_wrappers"]:
                # Use safe wrapper function
                safe_wrapper = cfg["safe_wrappers"][key]
                dispatch += (
                    f"  case SYSC_{n}: "
                    f"return detail::invoke<&{safe_wrapper}>({arg_list_str});\n"
                )
                handled = True
                break
            elif "method_casts" in cfg and key in cfg["method_casts"]:
                # Use manually specified method cast (for base class methods, special casts, etc.)
                # Requires "obj" to be specified in prefix_map for this prefix
                obj_name_from_prefix = cfg.get("obj", parts[0] if "_" in n else None)
                if obj_name_from_prefix:
                    dispatch += (
                        f"  case SYSC_{n}: "
                        f"return detail::invoke_method<&{obj_name_from_prefix}, {cfg['method_casts'][key]}>"
                        f"({arg_list_str});\n"
                    )
                    handled = True
                    break
            elif "method_names" in cfg and key in cfg["method_names"]:
                # Map syscall method name to actual method name (simple renaming)
                actual_method = cfg["method_names"][key]
                if parts[0] in object_type_aliases:
                    type_alias = object_type_aliases[parts[0]]
                    def extract_type(arg_str):
                        parts_inner = arg_str.strip().split()
                        if len(parts_inner) <= 1:
                            return arg_str.strip()
                        return " ".join(parts_inner[:-1])
                    arg_types = ", ".join(extract_type(a) for a in args) if args else ""
                    dispatch += (
                        f"  case SYSC_{n}: "
                        f"return detail::invoke_method<&{parts[0]}, "
                        f"static_cast<{ret} ({type_alias}::*)({arg_types})>(&{type_alias}::{actual_method})"
                        f">({arg_list_str});\n"
                    )
                    handled = True
                    break
            # If prefix matches but no override found, fall through to auto-detection
    
    if handled:
        continue
    
    # Auto-detect object method calls (ObjectName_methodName pattern)
    if "_" in n:
        parts = n.split("_", 1)
        if len(parts) == 2:
            obj_name = parts[0]
            method_name = parts[1]
            
            # Check if we detected this object automatically
            if obj_name in object_type_aliases:
                type_alias = object_type_aliases[obj_name]
                # Generate argument types string for method signature
                # Extract type (everything except the last word which is the parameter name)
                def extract_type(arg_str):
                    parts = arg_str.strip().split()
                    if len(parts) <= 1:
                        return arg_str.strip()
                    # Everything except the last part is the type
                    return " ".join(parts[:-1])
                arg_types = ", ".join(extract_type(a) for a in args) if args else ""
                
                # Auto-generate method dispatch using the detected type
                dispatch += (
                    f"  case SYSC_{n}: "
                    f"return detail::invoke_method<&{obj_name}, "
                    f"static_cast<{ret} ({type_alias}::*)({arg_types})>(&{type_alias}::{method_name})"
                    f">({arg_list_str});\n"
                )
                continue
    
    # Fallback: treat as free function
    dispatch += f"  case SYSC_{n}: return detail::invoke<&::{n}>({arg_list_str});\n"

write_file(os.path.join(KER_GEN, "kernel_sys_dispatch.inc.h"), dispatch)
print("kernel_sys_dispatch.inc.h generated")

# Generate jump table handlers for optimization #3
# Each handler is a function that calls the appropriate detail::invoke
# Note: Type aliases and includes are expected to be in the including file
handlers = "// Jump table handlers for syscall dispatch (optimization #3)\n"
handlers += "// Type aliases - must match those in kernel_sys_dispatch.inc.h\n"
handlers += "#ifndef __HAS_SYSCALL_TYPE_ALIASES\n"
handlers += "#define __HAS_SYSCALL_TYPE_ALIASES\n"
handlers += "using HSPI = std::remove_reference_t<decltype(SPI)>;\n"
handlers += "using HSerial = std::remove_reference_t<decltype(Serial)>;\n"
handlers += "using HWire = std::remove_reference_t<decltype(Wire)>;\n"
handlers += "#endif\n\n"

jump_table = "// Function pointer type for syscall handlers\n"
jump_table += f"typedef uintptr_t (*SyscallHandler)({gen_param_list(MAX_SYSCALL_ARGS, 'uintptr_t')});\n\n"

# Helper function to convert syscall name to camelCase handler name
def to_camel_case(name):
    """Convert syscall name (may contain underscores) to camelCase handler name.
    
    Capitalizes each word segment after splitting on underscores.
    Examples: 'pinMode' -> 'PinMode', 'Serial_begin' -> 'SerialBegin'
    """
    parts = name.split('_')
    if not parts:
        return name
    # Capitalize all parts for consistency (handler names should be capitalized)
    return ''.join(word.capitalize() for word in parts if word)

# Generate handler functions and jump table entries
jump_table_entries = []
for i, (n, ret, args, annot_type, annot_obj, annot_method) in enumerate(syscalls):
    arg_list_str = gen_arg_list(MAX_SYSCALL_ARGS)
    
    # Generate handler function name (camelCase per Google C++ style)
    handler_name = f"handle{to_camel_case(n)}"
    
    # Generate the invoke call (same logic as dispatch cases)
    invoke_call = ""
    
    if annot_type == "member":
        arg_types = ", ".join(a.split()[0] for a in args)
        invoke_call = (
            f"return detail::invoke_method<&{annot_obj}, "
            f"static_cast<{ret} ({annot_obj}::*)({arg_types})>(&{annot_obj}::{annot_method})"
            f">({arg_list_str});"
        )
    else:
        handled = False
        parts_for_prefix = n.split("_", 1) if "_" in n else [n, ""]
        for prefix, cfg in prefix_map.items():
            if n.startswith(prefix):
                key = n[len(prefix):]
                parts = parts_for_prefix
                if "safe_wrappers" in cfg and key in cfg["safe_wrappers"]:
                    safe_wrapper = cfg["safe_wrappers"][key]
                    invoke_call = f"return detail::invoke<&{safe_wrapper}>({arg_list_str});"
                    handled = True
                    break
                elif "method_casts" in cfg and key in cfg["method_casts"]:
                    obj_name_from_prefix = cfg.get("obj", parts[0] if "_" in n else None)
                    if obj_name_from_prefix:
                        invoke_call = (
                            f"return detail::invoke_method<&{obj_name_from_prefix}, {cfg['method_casts'][key]}>"
                            f"({arg_list_str});"
                        )
                        handled = True
                        break
                elif "method_names" in cfg and key in cfg["method_names"]:
                    actual_method = cfg["method_names"][key]
                    if parts[0] in object_type_aliases:
                        type_alias = object_type_aliases[parts[0]]
                        def extract_type(arg_str):
                            parts_inner = arg_str.strip().split()
                            if len(parts_inner) <= 1:
                                return arg_str.strip()
                            return " ".join(parts_inner[:-1])
                        arg_types = ", ".join(extract_type(a) for a in args) if args else ""
                        invoke_call = (
                            f"return detail::invoke_method<&{parts[0]}, "
                            f"static_cast<{ret} ({type_alias}::*)({arg_types})>(&{type_alias}::{actual_method})"
                            f">({arg_list_str});"
                        )
                        handled = True
                        break
        
        if not handled:
            if "_" in n:
                parts = n.split("_", 1)
                if len(parts) == 2:
                    obj_name = parts[0]
                    method_name = parts[1]
                    if obj_name in object_type_aliases:
                        type_alias = object_type_aliases[obj_name]
                        def extract_type(arg_str):
                            parts = arg_str.strip().split()
                            if len(parts) <= 1:
                                return arg_str.strip()
                            return " ".join(parts[:-1])
                        arg_types = ", ".join(extract_type(a) for a in args) if args else ""
                        invoke_call = (
                            f"return detail::invoke_method<&{obj_name}, "
                            f"static_cast<{ret} ({type_alias}::*)({arg_types})>(&{type_alias}::{method_name})"
                            f">({arg_list_str});"
                        )
                    else:
                        invoke_call = f"return detail::invoke<&::{n}>({arg_list_str});"
                else:
                    invoke_call = f"return detail::invoke<&::{n}>({arg_list_str});"
            else:
                invoke_call = f"return detail::invoke<&::{n}>({arg_list_str});"
    
    # Generate handler function with all 30 parameters
    handlers += (
        f"static inline uintptr_t {handler_name}({gen_param_list(MAX_SYSCALL_ARGS, 'uintptr_t')}) {{\n"
        f"  {invoke_call}\n"
        f"}}\n\n"
    )
    
    # Add to jump table
    jump_table_entries.append(f"  &{handler_name}")

jump_table += (
    "// Jump table array - index directly maps to syscall ID\n"
    "static const SyscallHandler syscallHandlers[] = {\n"
    + ",\n".join(jump_table_entries) + "\n};\n"
)

# Write jump table file
jump_table_content = handlers + "\n" + jump_table
write_file(os.path.join(KER_GEN, "kernel_sys_jumptable.inc.h"), jump_table_content)
print("kernel_sys_jumptable.inc.h generated")

# Generate syscall name array for debugging
names = "".join(f"  \"{n}\",\n" for n, _, _, _, _, _ in syscalls)
write_file(os.path.join(KER_GEN, "syscall_names.inc.h"), names)
print("syscall_names.inc.h generated")

# Generate app-side syscall wrappers
app = (
    "#pragma once\n"
    "#include <stddef.h>\n"
    "#include <stdint.h>\n"
    "\n"
    "#include \"syscall_ids.h\"\n"
)
# Generate extern declaration with MAX_SYSCALL_ARGS parameters
gate_params = gen_param_list(MAX_SYSCALL_ARGS)
app += ("extern \"C\" {\n"
        f"uintptr_t __syscall_raw(uint16_t, {gate_params});\n"
        "}\n"
        "\n")

# Generate inline wrapper function for each syscall
for n, ret, args, _, _, _ in syscalls:
    app += f"static inline {ret} {n}(" + ", ".join(args) + ") {\n"
    num_args = min(len(args), MAX_SYSCALL_ARGS)
    for i in range(MAX_SYSCALL_ARGS):
        app += f"  uintptr_t _p{i} = "
        if i < len(args):
            arg_parts = args[i].split()
            arg_name = arg_parts[-1]
            arg_type = " ".join(arg_parts[:-1])
            # Pointers use reinterpret_cast, other types use static_cast
            if "*" in arg_type:
                app += f"reinterpret_cast<uintptr_t>({arg_name});\n"
            else:
                app += f"static_cast<uintptr_t>({arg_name});\n"
        else:
            app += "0;\n"
    # Generate argument list for the syscall (use _p0, _p1, etc. variables)
    arg_call_list = gen_param_var_list(MAX_SYSCALL_ARGS)
    if ret == "void":
        app += (f"  __syscall_raw(SYSC_{n}, {arg_call_list});\n"
                f"  return;\n")
    else:
        app += (f"  return static_cast<{ret}>(__syscall_raw(SYSC_{n}, {arg_call_list}));\n")
    app += "}\n\n"

write_file(os.path.join(APP_GEN, "app_syscalls.h"), app)
print("app_syscalls.h generated")

# Generate raw syscall invoker - calls kernel gate function
# Optimization: Cache gate pointer to avoid lookup on every call
raw = (
    "#include <stddef.h>\n"
    "#include <stdint.h>\n"
    "\n"
    f"typedef uintptr_t (*Gate)(uint16_t, {gen_param_list(MAX_SYSCALL_ARGS)});\n"
    "Gate __syscall_gate_ptr(void);\n"
    "\n"
    "// Cached gate pointer - initialized on first call\n"
    "static Gate cached_gate = NULL;\n"
    "\n"
    f"uintptr_t __syscall_raw(uint16_t id, {gen_param_list(MAX_SYSCALL_ARGS)}) {{\n"
    "  // Cache gate pointer on first call (optimization #1)\n"
    "  if (cached_gate == NULL) {{\n"
    "    cached_gate = __syscall_gate_ptr();\n"
    "  }}\n"
    "  // Direct call without NULL check (optimization #2: gate is guaranteed non-NULL after init)\n"
    f"  return cached_gate(id, {gen_arg_list(MAX_SYSCALL_ARGS)});\n"
    "}\n"
)

write_file(os.path.join(APP_GEN, "app_sys_raw.c"), raw)
print("app_sys_raw.c generated")

print("\nSyscall generation complete!\n")
